#!/bin/bash

# set -euxo pipefail  # For debugging this script
set -uo pipefail  # For release

# Reasoning: Accepting that it's a Really Bad Idea (Trump-case used for emphasis) to 
# create any kind of backup or kkk of a validator for the sake of being able to 
# bring up a stack when one dies (because slashing), We've created tools that try to
# make it exceedingly easy and safe to replace an existing server with a new one.
# At no time will there be two instances of a stack. If you want to switch components,
# you tear down the old one and build the new one, keeping any portable data (ie. the chain db).
# We want this to be
# a well-worn path that always just works, with a minimum of fuss. As with any kind of backup
# strategy, if you don't rehearse the "restore" half of the process frequently,
# bit rot (the entropic tendency of all systems to move toward disorder) all but guarantees
# that it will fail just when you need it the most.
# A full rehearsal can be done here with just a single command: "make redploy-from-scratch". That target
# does it all: bring down gracefully, clean, configure, build, run, test, go-live.
#
# Just to say: Using Docker is a great choice for doing this. Well played, my fellow
# eth-dockerians.

# Terminology: Note that the scope of the term "rebuild" in our context encompasses not just
# code rebuilding, but also the creation and bringing-up of containers. This is in the
# spririt of provisioning systems like Terraform, wherein...
# Instance == running container. Artiface, but a helpful abstraction.

# Model: Targets that build targets are idempotent --and fast if nothing needs to be done.

# TODO: Add functions to handle deposits to both mainnet and testnet. Add admonishiments about
# saving secrets and links to doc pages like:
#     https://eth-docker.net/docs/Support/Recommendations/

# TODO: Consider using that same terminal-GUI thing that the ethd file uses for setup.
# Is that really better than purely CLI? I suppose so. For a multi-step workflow like
# key setup? Can you go back? I don't think so.

# TODO: Look again at how to delete cached command layers without building:
#    docker images --no-trunc --format '{{.ID}}' | xargs docker rmi
# AH! Looks like this might be the ticket:
#    docker builder prune
# of
#    docker builder prune -af
#
# TODO: Consider building a terminal-based window thing (name?) to use like iTerm solution. Instead of?
# 
# TODO: Add a warning function that can call with all other top-level functions that pesters the user
# to do things like deleting secrets when no longer needed. Call it "pester" "gentle-reminder" or something.
# Or maybe generalize to be "before-run" and "after-run-hook"
# 
# TODO: Figure out how specify mainnet/production vs testnet (which chain?) Extra strong warnings for mainnet?
#
# TODO: Consider not allowing the force param to suppress confirmation dialog when dealing with volumes and the 
# beacon chain data. "You're using the 'force' param, but this is too important not to ask: Are you SURE you 
# want to delete your beacon chain data? It can take weeks to restore it". " Last chance. Are you really, REALLY sure you want
# to delete your beacon chain data? Don't say I didn't warn you."




#-------------------------------------------------------------------------------------
# Web Pages
#-------------------------------------------------------------------------------------

## Open documentation
open-docs()
{
    open https://eth-docker.net/docs/Usage/ClientSetup
}

## Open beaconcha.in page on our validator
PUBLIC_KEY=800008215f7de68bf2804079aa778d0034a95bbe83d5662ef174db3d9343e3ead6f48f53890e225cc834972e5e04ef6a
open-beaconchain()
{
    open https://beaconcha.in/validator/${PUBLIC_KEY}
}


#-------------------------------------------------------------------------------------
# Shortcuts
# TODO: Think about whether these are really useful, or not
#-------------------------------------------------------------------------------------

## Start containers
start()
{
    instances-build
}

## Stop containers
stop()
{
    instances-clean
}

## Restart containers
restart()
{
    instances-rebuild
}

# Show all persistent data like volumes, build layer caches, config files
data-store-summary()
{
	echo tbd
}


#-------------------------------------------------------------------------------------
# Platform
#-------------------------------------------------------------------------------------

# Choose or auto-detect your platform and record somewhere so that platform-dependent
# targets can use it.


#-------------------------------------------------------------------------------------
# Development environment setup
#-------------------------------------------------------------------------------------

# To check that xcode tools are installed: https://mac.install.guide/commandlinetools/2.html

# TODO: Have install step auto-detect the platform

#- Install tools needed to build everything
tools-build()
{
	tools-build-mac
}

#- Install tools needed to build everything
tools-clean()
{
	tools-clean-mac
}

#- Re-build tools needed to build everything
tools-rebuild()
{
	tools-clean
	tools-build
}

#- Set up Mac dev environment
tools-build-mac()
{
    # Install Apple XCode command line tools
    if xcode-is-installed; then
        echo Mac Xcode command line tools are already installed
    else
        echo Installing Mac Xcode command line tools
        xcode-select --install
    fi

    # Install Homebrew package manager
    # See: https://brew.sh/
	if homebrew-is-installed; then
        echo Homebrew package manager is already installed
    else
        echo Installing Homebrew package manager
		/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
	fi

    # Install GNU Coreutils
    # See: https://www.gnu.org/software/coreutils/
    homebrew-package-check-install coreutils

    # Install newt
    # See: https://pagure.io/newt
    homebrew-package-check-install newt
}

docker-sudo-hack()
{
	# Find or create a "docker" group
	if group-exists docker; then
		echo A "docker" group already exists
	else
		echo Creating "docker" group
		sudo groupadd docker
	fi

	# Add user to the "docker" group
	if user-is-in-group $USER docker; then
		echo User $USER is already in the docker group
	else
		echo Adding $USER to the docker group
		sudo usermod --append --groups docker $USER
		echo You must re-log in for this to take effect
		# TODO: Prompt to do this now (ie. exit shell)
	fi
}

group-exists()
{
	declare -r name=$1
	getent group $name &> /dev/null
}

user-is-in-group()
{
	declare -r userName=$2
	declare -r groupName=$1
	getent group $userName | grep $groupName &> /dev/null
}

xcode-is-installed()
{
    xcode-select --print-path 1>/dev/null
}

homebrew-is-installed()
{
    command -v brew &> /dev/null
}

homebrew-package-is-installed()
{
	declare -r name=$1
    brew list $name &>/dev/null
}

homebrew-package-install()
{
	declare -r name=$1
	echo Installing $name
	brew install $name
}

homebrew-package-remove()
{
	declare -r name=$1
	echo Removing $name
	brew uninstall $name
}

homebrew-package-check-install()
{
	declare -r name=$1
    if homebrew-package-is-installed $name; then
        echo $1 package is already installed
    else
        homebrew-package-install $name
    fi
}

homebrew-package-check-remove()
{
	declare -r name=$1
    if homebrew-package-is-installed $name; then
		homebrew-package-remove $name
    else
        echo $name package already removed
    fi
}

#- Set up Windows dev environment
tools-build-win()
{
	@echo Not yet implemented. Volunteers?
}

#- Set up Clear Linux dev environment
tools-build-clear-linux()
{
	sudo swupd update

	swupd-package-check-install zsh
	swupd-package-check-install docker-compose
	swupd-package-check-install devpkg-newt
	swupd-package-check-install gh

	sudo systemctl enable docker
	sudo systemctl start docker

	# TODO: Need to change storage driver for prod?
	# See: https://docs.01.org/clearlinux/latest/tutorials/docker.html
}

# TODO: Add support for "gh auth login"
# And 
	# git config --global user.email "you@example.com"
	# git config --global user.name "Your Name"


tools-clear-clear-linux()
{
	echo TBD
}

swupd-package-is-installed()
{
	declare -r name=$1
	sudo swupd bundle-info $name | grep "Explicitly installed" > /dev/null
}

swupd-package-install()
{
	declare -r name=$1
    echo Installing $name
	sudo swupd bundle-add $name
}

swupd-package-remove()
{
	declare -r name=$1
    echo Removing $name
	sudo swupd bundle-remove $name
}

swupd-package-check-install()
{
	declare -r name=$1
    if swupd-package-is-installed $name; then
        echo $name package is already installed
    else
		swupd-package-install $name
    fi
}

swupd-package-check-remove()
{
	declare -r name=$1
    if swupd-package-is-installed $name; then
		swupd-package-remove $name
    else
        echo $name package already removed
    fi
}

#- Uninstall Mac dev env
tools-clean-mac()
{
	# TODO: Check flag for expunging. Default should be *not* to expunge, because folks may already have
	# these tools and may have dependencies on them

    homebrew-package-check-remove newt
    homebrew-package-check-remove coreutils
    # TODO: Decide whether we really do want to remove Homebrew and Xcode completely. Or the others, for that matter
}

#- Uninstall Windows dev env
tools-clean-win()
{
	echo Not yet implemented. Volunteers?
}

#- Uninstall Clear Linux dev environment
tools-clean-clear-linux()
{
	echo Not yet implemented. Volunteers?
}


#-------------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------------

config-build-interactive()
{
    if git-has-uncommitted-changes; then
        echo You have uncommitted changes in Git. We need to switch branches, so you\'ll need to commit those first
        exit
    fi
	DOCKER_BUILDKIT=0 COMPOSE_DOCKER_CLI_BUILD=0 ./ethd config
	./ethd update
}

config-build()
{
    cp env-trent .env
}

config-clean()
{
	confirm-or-exit "Are you sure you want to delete all \".env*\" files?"
	rm -f .env*
}

config-rebuild()
{
	config-clean
	config-build
}

config-show()
{
	less .env
}

config-firewall-clear-linux()
# TODO:
#   execution client: 30303 tcp/udp, forwarded to your server
#   lighthouse: 9000 tcp/udp, forwarded to your server
#   prysm: 13000 tcp and 12000 udp, forwarded to your server
#   grafana/web UI: 443 tcp, forwarded to your server, assuming you are using the reverse proxy.
{
	echo Not yet implemented
}

git-has-uncommitted-changes()
{
    [[ -n $(git status -s) ]]
}


#-------------------------------------------------------------------------------------
# Keys
#-------------------------------------------------------------------------------------

keys-build()
{
	confirm-or-exit "If you're creating keys for mainnet, do this on an airgapped machine. Continue?"
	query "What is your withdrawal wallet public address?" walletAddress

    docker-compose run \
		--rm deposit-cli-new \
		--eth1_withdrawal_address $walletAddress \
		--uid $(id --user)
}

keys-clean()
{
	confirm-or-exit "Are you sure you want to delete the keys?"

	rm -f ./.eth/validator_keys/deposit_data-*.json
	rm -f ./.eth/validator_keys/keystore-*.json
}

# See: https://eth-docker.net/docs/Usage/ConfigureWallet
keys-check()
{
	query "What is your withdrawal wallet public address?" walletAddress
    docker-compose run \
		--rm deposit-cli-existing \
		--folder seed_check \
		--eth1_withdrawal_address $walletAddress \
		--uid $(id --user)
    diff -s \
		.eth/validator_keys/deposit_data*.json \
		.eth/seed_check/deposit_data*.json
    rm .eth/seed_check/*
}

# See: https://eth-docker.net/docs/Usage/ImportKeys
keys-import()
{
	# TODO: Consider factoring this out
	./ethd keyimport
}


#-------------------------------------------------------------------------------------
# Image
#-------------------------------------------------------------------------------------

#- Build image
images-build()
{
	docker-compose build --pull
	
	# TODO: Add the "--squash" option here and test
}

#- Delete image
images-clean()
{
	# confirm-or-exit "Are you sure you want to delete all images?"

	# TODO: DOES THIS BELONG HERE?
	# networks-clean

	docker-compose down --rmi all

	# if ${LAYERS}; then
	# 	layers-clean
	# fi
}

#- Rebuild image
images-rebuild()
{
	images-clean
	images-build
}

## Prune orphan images
# TODO: Limit to project?
images-prune()
{
    docker image prune
}

## List all eth-docker images
images-list()
{
	docker images --filter label=com.docker.compose.project=eth-docker
}

#- List layers in image
# images-list-layers()
# {
# 	@docker history ${IMAGE_NAME}:${PROJECT_VERSION}
# }

#- List layers in image without truncating command lines
# images-list-layers-full()
# {
# 	@docker history --no-trunc ${IMAGE_NAME}:${PROJECT_VERSION}
# }


#-------------------------------------------------------------------------------------
# Containers
#-------------------------------------------------------------------------------------

#- Create containers from images
containers-build()
{
	docker-compose up --no-recreate --no-build --no-start
}

#- Delete containers
containers-clean()
{
	# confirm-or-exit "Are you sure you want to delete all containers?"

	# Make sure no containers are running. We can't delete them, if they are
	instances-clean

	docker-compose rm --force

	# if ${NETWORKS}; then
	# 	networks-clean
	# fi

	# if ${VOLUMES}; then
	# 	volumes-clean
	# fi
}

#- Rebuild container
containers-rebuild()
{
	containers-clean
	containers-build
}

containers-list()
{
    docker ps --all --filter label=com.docker.compose.project=eth-docker
}

## Prune orphan/unreferenced containers
# TODO: Limit to project?
containers-prune()
{
	docker container prune
}


#-------------------------------------------------------------------------------------
# Instances
#
# (Running containers)
#-------------------------------------------------------------------------------------

#- Start container instances
instances-build()
{
	docker-compose start
}

#- Stop container instances
instances-clean()
{
	# confirm-or-exit "Are you sure you want to stop all running containers?"

	docker-compose stop
}

#- Restart container instances
instances-rebuild()
{
	docker-compose restart
}

#- List container instances
instances-list()
{
    docker ps --filter label=com.docker.compose.project=eth-docker
}

## Check health of container and its processes
instances-health()
{
	@printf "Container health check: " && docker inspect ${CONTAINER_NAME} | jq '.[].State.Health.Status'
}


#-------------------------------------------------------------------------------------
# Logging
#-------------------------------------------------------------------------------------

logs-all()
{
	docker-compose logs --follow --tail 100
}

logs-consensus()
{
	docker-compose logs --follow --tail 100 consensus
}

logs-validator()
{
	docker-compose logs --follow --tail 100 validator
}

logs-execution()
{
	docker-compose logs --follow --tail 100 execution
}

dashboards()
{
	open http://moneybox:3000/d/nQaRO6Yiz/prysm_ynager?orgId=1&refresh=30s
}

tmux-session-list()
{
	tmux ls
}

tmux-console-build()
{
	# Create the console session
	declare -r session=console
	tmux new-session -d -s $session

	# Build a dashboard in the first window
	declare -r consoleWindow=0
	tmux rename-window -t $session:$consoleWindow 'Dashboard'
	tmux send-keys -t $session:$consoleWindow 'htop' C-m

	tmux split-window -v './easy logs-consensus'
	tmux split-window -v './easy logs-execution'
	tmux split-window -v './easy logs-validator'

	tmux select-layout even-vertical

	# tmux split-window -v
	# tmux split-window -v
	# tmux split-window -v

	# tmux split-window -t $session:$consoleWindow -v -p 50
	# declare -r bottomPane = $TMUX_PANE

	# tmux split-window -t $bottomPane -v -p 50 

	# tmux split-window -t $session:$consoleWindow -v -p 50 
	# tmux split-window -v -p 50 

	# tmux split-window -v -p 75 './easy logs-consensus'
	# tmux split-window -v -p 66 './easy logs-execution'
	# tmux split-window -v -p 50 './easy logs-validator'

	# Put a shell into the second window
	# declare -r shellWindow=1
	# tmux new-window -t $session:$shellWindow -n 'Shell'
	# tmux send-keys -t $session:$shellWindow 'zsh' C-m 'clear' C-m

	# # Go back to console window
	# tmux select-window -t $session:$consoleWindow
}

tmux-console-clean()
{
	# TODO: Have to test whether already running so we don't abort
	
	# confirm-or-exit "Are you sure you want to kill the tmux logs session?"
	tmux kill-session -t console
}

tmux-console-rebuild()
{
	tmux-console-clean
	tmux-console-build
}

tmux-console-attach()
{
	tmux attach-session -t console
}

tmux-console-rebuild-attach()
{
	tmux-console-rebuild
	tmux-console-attach
}


#-------------------------------------------------------------------------------------
# Volumes
#-------------------------------------------------------------------------------------

# TODO: There is no "docker-compose volume ls" to limit to volumes related to a project.
# We need to use the "--filter" parameter of "docker volume ls" to accomplish this.
# See: https://docs.docker.com/engine/reference/commandline/volume_ls/#filtering
volumes-list()
{
	docker volume ls
}

volumes-prune()
{
	docker volume prune
}

volumes-clean()
{
	echo TBD
	# See: https://eth-docker.net/docs/Support/Testing/
	# sudo docker volume rm $(sudo docker volume ls -q | grep eth-docker), wipe volumes from last pass,
	# assuming that eth-docker is the directory we are testing in.
}

volumes-beacon-size()
{
	sudo du --bytes --total /var/lib/docker/volumes/eth-docker_prysmbeacon-data/_data/beaconchaindata
}


#-------------------------------------------------------------------------------------
# Networks
#-------------------------------------------------------------------------------------

# TODO: There is no "docker-compose network ls" to limit to networks related to a project.
# We need to use the "--filter" parameter of "docker network ls" to accomplish this.
# See: https://docs.docker.com/engine/reference/commandline/network_ls/#filtering
networks-list()
{
	docker network ls
}

networks-prune()
{
	docker network prune
}


#-------------------------------------------------------------------------------------
# Deployment
#-------------------------------------------------------------------------------------

build-from-scratch()
{
	tools-build
	config-build
	images-build
	containers-build
	instances-build
}

clean-to-scratch()
{
	instances-clean
	containers-clean
	images-clean
	config-clean
	tools-clean
}

rebuild-from-scratch()  
{
	clean-to-scratch
	build-from-scratch
}

build-from-tools()
{
	config-build
	images-build
	containers-build
	instances-build
}

clean-to-tools()
{
	instances-clean
	containers-clean
	images-clean
	config-clean
}

rebuild-from-tools()  
{
	clean-to-tools
	build-from-tools
}

build-from-config()
{
	images-build
	containers-build
	instances-build
}

clean-to-config()
{
	instances-clean
	containers-clean
	images-clean
}

rebuild-from-config()  
{
	clean-to-config
	build-from-config
}

build-from-images()
{
	containers-build
	instances-build
}

clean-to-images()
{
	instances-clean
	containers-clean
}

rebuild-from-images()  
{
	clean-to-images
	build-from-images
}

build-from-containers()
{
	instances-build
}

clean-to-containers()
{
	instances-clean
}

rebuild-from-containers()  
{
	clean-to-containers
	build-from-containers
}


#-------------------------------------------------------------------------------------
# Usage
#-------------------------------------------------------------------------------------

printhelp() {
    me=$(basename "${BASH_SOURCE}")
    echo "usage: ${me} [help|-h|--help] <subcommand>"
    echo ""
    echo "optional arguments:"
    echo "  help | -h | --help"
    echo "    print this message and exit"
    echo ""
    echo "subcommands:"
    echo "  config "
    echo "     configures eth-docker with your choice of Ethereum clients"
}

if [[ "$#" -eq 0 || "$1" == "help" || "$1" == "-h" || "$1" == "--help" ]]; then
    printhelp
fi


#-------------------------------------------------------------------------------------
# Helpers
#-------------------------------------------------------------------------------------

confirm-or-exit()
{
	declare -r prompt=$1
	while true; do
        read -rp "$prompt (No/Yes) " yn
        case $yn in
            [Yy]es ) break;;
            * ) echo "Aborting, no changes made"; exit 1;;
        esac
    done
}

query()
{
	declare -r prompt=$1
	declare resultVariable=$2
	echo -n "$prompt and press [ENTER]: "
	read response
    eval $resultVariable="'$response'"
}

test()
{
	query "Please enter your wallet address" response
	echo $response
}


#-------------------------------------------------------------------------------------
# Usage
#-------------------------------------------------------------------------------------

## Print Makefile usage for standard targets.
# 	@grep -h -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
usage()
{
	grep -h -E '^## .*$$' ./easy | sort | awk 'BEGIN {FS = "## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
}

## Print Makefile usage for internal targets.
# 	@grep -h -E '^[a-zA-Z_-]+:.*?#- .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?#- "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
usage-internal()
{
	grep -h -E '^#- .*$$' ./easy | sort | awk 'BEGIN {FS = "#- "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
}


#-------------------------------------------------------------------------------------
# Key/Value Store
#
# Origin: https://helloacm.com/the-simplest-database-implementation-by-bash-programming/#:~:text=The%20BASH%20database%20provides%20four,an%20entry%20from%20the%20database
#
# TODO: This needs to check before appending, or will get duplicates...
#
# TODO: Consider replacing with this: https://github.com/reddec/bash-db/blob/master/db.sh
#-------------------------------------------------------------------------------------

DATABASE_FILE=.database
 
function db_clear()
{
	rm -f "$DATABASE_FILE"
}

function db_dump()
{
	cat "$DATABASE_FILE"
}
 
function db_set()
{
	declare -r key=$1
	declare -r value=$2
	echo "$key,$value" >> "$DATABASE_FILE"
}
 
function db_get()
{
	declare -r key=$1
	grep "^$key," "$DATABASE_FILE" | sed -e "s/^$key,//" | tail -n 1
}
 
# TODO: Not really remove. Would need a gc function...
function db_remove()
{
	declare -r key=$1
	db_set $key ""
}


#-------------------------------------------------------------------------------------
# Execution wrapper
#-------------------------------------------------------------------------------------

command="$1"
shift

"$command" $@
