#!/bin/bash

# set -euxo pipefail  # For debugging this script
set -uo pipefail  # For release

# Reasoning: Accepting that it's a Really Bad Idea (Trump-case used for emphasis) to 
# create any kind of backup or kkk of a validator for the sake of being able to 
# bring up a stack when one dies (because slashing), We've created tools that try to
# make it exceedingly easy and safe to replace an existing server with a new one.
# At no time will there be two instances of a stack. If you want to switch components,
# you tear down the old one and build the new one, keeping any portable data (ie. the chain db).
# We want this to be
# a well-worn path that always just works, with a minimum of fuss. As with any kind of backup
# strategy, if you don't rehearse the "restore" half of the process frequently,
# bit rot (the entropic tendency of all systems to move toward disorder) all but guarantees
# that it will fail just when you need it the most.
# A full rehearsal can be done here with just a single command: "make redploy-from-scratch". That target
# does it all: bring down gracefully, clean, configure, build, run, test, go-live.
#
# Just to say: Using Docker is a great choice for doing this. Well played, my fellow
# eth-dockerians.

# Terminology: Note that the scope of the term "rebuild" in our context encompasses not just
# code rebuilding, but also the creation and bringing-up of containers. This is in the
# spririt of provisioning systems like Terraform, wherein...
# Instance == running container. Artiface, but a helpful abstraction.

# Model: Targets that build targets are idempotent --and fast if nothing needs to be done.

# TODO: Add functions to handle deposits to both mainnet and testnet. Add admonishiments about
# saving secrets and links to doc pages like:
#     https://eth-docker.net/docs/Support/Recommendations/

# TODO: Consider using that same terminal-GUI thing that the ethd file uses for setup.
# Is that really better than purely CLI? I suppose so. For a multi-step workflow like
# key setup? Can you go back? I don't think so.

# TODO: Look again at how to delete cached command layers without building:
#    docker images --no-trunc --format '{{.ID}}' | xargs docker rmi
# AH! Looks like this might be the ticket:
#    docker builder prune
# of
#    docker builder prune -af
#
# TODO: Consider building a terminal-based window thing (name?) to use like iTerm solution. Instead of?
# 
# TODO: Add a warning function that can call with all other top-level functions that pesters the user
# to do things like deleting secrets when no longer needed. Call it "pester" "gentle-reminder" or something.
# Or maybe generalize to be "before-run" and "after-run-hook"
# 
# TODO: Figure out how specify mainnet/production vs testnet (which chain?) Extra strong warnings for mainnet?
#
# TODO: Change to this form:
#
# if cond then
#	do something
# fi
#
# if cond then
#	do something
# else
#	do something else
# fi
#
# TODO: Consider not allowing the force param to suppress confirmation dialog when dealing with volumes and the 
# beacon chain data. "You're using the 'force' param, but this is too important not to ask: Are you SURE you 
# want to delete your beacon chain data? It can take weeks to restore it". " Last chance. Are you really, REALLY sure you want
# to delete your beacon chain data? Don't say I didn't warn you."


## Open documentation
open-docs()
{
    open https://eth-docker.net/docs/Usage/ClientSetup
}


#-------------------------------------------------------------------------------------
# Shortcuts
# TODO: Think about whether these are really useful, or not
#-------------------------------------------------------------------------------------

## Start containers
start()
{
    instances-build
}

## Stop containers
stop()
{
    instances-clean
}

## Restart containers
restart()
{
    instances-rebuild
}

# Show all persistent data like volumes, build layer caches, config files
data-store-summary()
{
	echo tbd
}


#-------------------------------------------------------------------------------------
# Platform
#-------------------------------------------------------------------------------------

# Choose or auto-detect your platform and record somewhere so that platform-dependent
# targets can use it.


#-------------------------------------------------------------------------------------
# Development environment setup
#-------------------------------------------------------------------------------------

# To check that xcode tools are installed: https://mac.install.guide/commandlinetools/2.html

# TODO: Have install step auto-detect the platform

#- Install tools needed to build everything
tools-build()
{
	tools-build-mac
}

#- Install tools needed to build everything
tools-clean()
{
	tools-clean-mac
}

#- Re-build tools needed to build everything
tools-rebuild()
{
	tools-clean
	tools-build
}

#- Set up Mac dev environment
tools-build-mac()
{
    # Install Apple XCode command line tools
    if xcode-is-installed
    then
        echo Mac Xcode command line tools are already installed
    else
        echo Installing Mac Xcode command line tools
        xcode-select --install
    fi

    # Install Homebrew package manager
    # See: https://brew.sh/
	if homebrew-is-installed
    then
        echo Homebrew package manager is already installed
    else
        echo Installing Homebrew package manager
		/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
	fi

    # Install GNU Coreutils
    # See: https://www.gnu.org/software/coreutils/
    homebrew-package-check-install coreutils

    # Install newt
    # See: https://pagure.io/newt
    homebrew-package-check-install newt
}

xcode-is-installed()
{
    xcode-select --print-path 1>/dev/null
}

homebrew-is-installed()
{
    command -v brew &> /dev/null
}

homebrew-package-is-installed()
{
    brew list $1 &>/dev/null
}

homebrew-package-check-install()
{
    if homebrew-package-is-installed $1
    then
        echo $1 package is already installed
    else
        echo Installing $1
	    brew install $1
    fi
}

homebrew-package-check-uninstall()
{
    if homebrew-package-is-installed $1
    then
        echo Uninstalling $1
	    brew uninstall $1
    else
        echo $1 package is already uninstalled
    fi
}

#- Set up Windows dev environment
tools-build-win()
{
	@echo Not yet implemented. Volunteers?
}

#- Set up Clear Linux dev environment
tools-build-clear-linux()
{
	sudo swupd update
	sudo swupd bundle-add containers-basic
	sudo swupd bundle-add docker-compose
	sudo systemctl enable docker
	sudo systemctl start docker

	# TODO: Need to change storage driver for prod?
	# See: https://docs.01.org/clearlinux/latest/tutorials/docker.html
}

#- Uninstall Mac dev env
tools-clean-mac()
{
	# TODO: Check flag for expunging. Default should be *not* to expunge, because folks may already have
	# these tools and may have dependencies on them

    homebrew-package-check-uninstall newt
    homebrew-package-check-uninstall coreutils
    # TODO: Decide whether we really do want to remove Homebrew and Xcode completely. Or the others, for that matter
}

#- Uninstall Windows dev env
tools-clean-win()
{
	echo Not yet implemented. Volunteers?
}

#- Uninstall Clear Linux dev environment
tools-clean-clear-linux()
{
	echo Not yet implemented. Volunteers?
}


#-------------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------------

config-build-interactive()
{
    if git-has-uncommitted-changes
    then
        echo You have uncommitted changes in Git. We need to switch branches, so you\'ll need to commit those first
        exit
    fi
	DOCKER_BUILDKIT=0 COMPOSE_DOCKER_CLI_BUILD=0 ./ethd config
	./ethd update
}

config-build()
{
    cp env-trent .env
}

config-clean()
{
	rm -f .env*
}

config-rebuild()
{
	config-clean
	config-build
}

config-show()
{
	less .env
}

config-create-keys()
{
    sudo docker-compose run --rm deposit-cli-new --eth1_withdrawal_address YOURHARDWAREWALLETADDRESS --uid $(id -u)
}

# See: https://eth-docker.net/docs/Usage/ConfigureWallet
config-check-keys()
{
    sudo docker-compose run --rm deposit-cli-existing --folder seed_check --eth1_withdrawal_address YOURHARDWAREWALLETADDRESS --uid $(id -u)
    diff -s .eth/validator_keys/deposit_data*.json .eth/seed_check/deposit_data*.json
    rm .eth/seed_check/*
}

# See: https://eth-docker.net/docs/Usage/ImportKeys
config-import-keys()
{
	echo Not yet implemented
}

config-firewall-clear-linux()
# TODO:
#   execution client: 30303 tcp/udp, forwarded to your server
#   lighthouse: 9000 tcp/udp, forwarded to your server
#   prysm: 13000 tcp and 12000 udp, forwarded to your server
#   grafana/web UI: 443 tcp, forwarded to your server, assuming you are using the reverse proxy.
{
	echo Not yet implemented
}

git-has-uncommitted-changes()
{
    [[ -n $(git status -s) ]]
}


#-------------------------------------------------------------------------------------
# Image
#-------------------------------------------------------------------------------------

#- Build image
# TODO: Try to get rid of the "--pull" option here
images-build()
{
	docker-compose --project-name ethd build --pull
}

test()
{
	confirm-or-exit "WARNING - this action will destroy data stores. Do you wish to continue? (No/Yes) "
}

#- Delete image
images-clean()
{
	# TODO: DOES THIS BELONG HERE?
	# networks-clean

	docker-compose down --rmi all

	# if ${LAYERS}
	# then
	# 	layers-clean
	# fi
}

#- Rebuild image
images-rebuild()
{
	images-clean
	images-build
}

## Prune orphan images
# TODO: Limit to project?
images-prune()
{
    docker image prune
}

## List all eth-docker images
images-list()
{
	docker-compose images
}

#- List layers in image
images-list-layers()
{
	@docker history ${IMAGE_NAME}:${PROJECT_VERSION}
}

#- List layers in image without truncating command lines
images-list-layers-full()
{
	@docker history --no-trunc ${IMAGE_NAME}:${PROJECT_VERSION}
}


#-------------------------------------------------------------------------------------
# Containers
#
# (Not running)
#-------------------------------------------------------------------------------------

#- Create containers from images
# TODO: Why does this build pull a bunch of other images? I want to have all the images
# in place by the time we get here. The "images-build" function should do this.
containers-build()
{
	docker-compose create --no-build --no-recreate
}

#- Delete containers
# TODO: Not all containers are removed: teku:local and besu:local
containers-clean()
{
	# Make sure no containers are running. We can't delete them, if they aren't
	instances-clean

	docker-compose rm

	# if ${NETWORKS}
	# then
	# 	networks-clean
	# fi

	# if ${VOLUMES}
	# then
	# 	volumes-clean
	# fi
}

#- Rebuild container
containers-rebuild()
{
	containers-clean
	containers-build
}

containers-list()
{
    docker compose ps \
		--status=created \
		--status=exited \
		--status=removing \
		--status=dead
}

## Prune orphan/unreferenced containers
# TODO: Limit to project?
containers-prune()
{
	docker container prune
}


#-------------------------------------------------------------------------------------
# Instances
#
# (Running containers)
#-------------------------------------------------------------------------------------

#- Start container instances
instances-build()
{
	docker compose start
}

#- Stop container instances
instances-clean()
{
	docker compose stop
}

#- Restart container instances
instances-rebuild()
{
	docker compose restart
}

#- List container instances
instances-list()
{
    docker compose ps \
		--status=running \
		--status=restarting \
		--status=paused
}

## Show container instances logs
instances-logs()
{
	docker compose logs --follow --tail 100
}

## Check health of container and its processes
instances-health()
{
	@printf "Container health check: " && docker inspect ${CONTAINER_NAME} | jq '.[].State.Health.Status'
}


#-------------------------------------------------------------------------------------
# Volumes
#-------------------------------------------------------------------------------------

# TODO: There is no "docker compose volume ls" to limit to volumes related to a project.
# We need to use the "--filter" parameter of "docker volume ls" to accomplish this.
# See: https://docs.docker.com/engine/reference/commandline/volume_ls/#filtering
volumes-list()
{
	docker volume ls
}

volumes-prune()
{
	docker volume prune
}


#-------------------------------------------------------------------------------------
# Networks
#-------------------------------------------------------------------------------------

# TODO: There is no "docker compose network ls" to limit to networks related to a project.
# We need to use the "--filter" parameter of "docker network ls" to accomplish this.
# See: https://docs.docker.com/engine/reference/commandline/network_ls/#filtering
networks-list()
{
	docker network ls
}

networks-prune()
{
	docker network prune
}


#-------------------------------------------------------------------------------------
# Deployment
#-------------------------------------------------------------------------------------

build-from-scratch()
{
	tools-build
	config-build
	images-build
	containers-build
	instances-build
}

clean-to-scratch()
{
	instances-clean
	containers-clean
	images-clean
	config-clean
	tools-clean
}

rebuild-from-scratch()  
{
	clean-to-scratch
	build-from-scratch
}

build-from-tools()
{
	config-build
	images-build
	containers-build
	instances-build
}

clean-to-tools()
{
	instances-clean
	containers-clean
	images-clean
	config-clean
}

rebuild-from-tools()  
{
	clean-to-tools
	build-from-tools
}

build-from-config()
{
	images-build
	containers-build
	instances-build
}

clean-to-config()
{
	instances-clean
	containers-clean
	images-clean
}

rebuild-from-config()  
{
	clean-to-config
	build-from-config
}

build-from-images()
{
	containers-build
	instances-build
}

clean-to-images()
{
	instances-clean
	containers-clean
}

rebuild-from-images()  
{
	clean-to-images
	build-from-images
}

build-from-containers()
{
	instances-build
}

clean-to-containers()
{
	instances-clean
}

rebuild-from-containers()  
{
	clean-to-containers
	build-from-containers
}


#-------------------------------------------------------------------------------------
# Usage
#-------------------------------------------------------------------------------------

printhelp() {
    me=$(basename "${BASH_SOURCE}")
    echo "usage: ${me} [help|-h|--help] <subcommand>"
    echo ""
    echo "optional arguments:"
    echo "  help | -h | --help"
    echo "    print this message and exit"
    echo ""
    echo "subcommands:"
    echo "  config "
    echo "     configures eth-docker with your choice of Ethereum clients"
}

if [[ "$#" -eq 0 || "$1" == "help" || "$1" == "-h" || "$1" == "--help" ]]; then
    printhelp
fi


#-------------------------------------------------------------------------------------
# Helpers
#-------------------------------------------------------------------------------------

confirm-or-exit()
{
	while true; do
        read -rp "$1" yn
        case $yn in
            [Yy]es ) break;;
            * ) echo "Aborting, no changes made"; exit 1;;
        esac
    done
}

query()
{
	# Pass query string, accept, reject strings. Return boolean
	# Default the accept reject strings?
	echo Not yet implemented
}


#-------------------------------------------------------------------------------------
# Usage
#-------------------------------------------------------------------------------------

## Print Makefile usage for standard targets.
# 	@grep -h -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
usage()
{
	grep -h -E '^## .*$$' ./easy | sort | awk 'BEGIN {FS = "## "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
}

## Print Makefile usage for internal targets.
# 	@grep -h -E '^[a-zA-Z_-]+:.*?#- .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?#- "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
usage-internal()
{
	grep -h -E '^#- .*$$' ./easy | sort | awk 'BEGIN {FS = "#- "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
}


#-------------------------------------------------------------------------------------
# Execution wrapper
#-------------------------------------------------------------------------------------

command="$1"
shift

"$command" $@
